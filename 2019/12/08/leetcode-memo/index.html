<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="739.Daily TemperaturesConcise: For each element, find the first element which is greater than it. Solution1: Monotonic stack  Time Complexity: O(n)Space Complexity: O(n) Solution2: Jump jump jump Time">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode memo">
<meta property="og:url" content="http://yoursite.com/2019/12/08/leetcode-memo/index.html">
<meta property="og:site_name" content="Siil&#39;s Blog">
<meta property="og:description" content="739.Daily TemperaturesConcise: For each element, find the first element which is greater than it. Solution1: Monotonic stack  Time Complexity: O(n)Space Complexity: O(n) Solution2: Jump jump jump Time">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-01-06T14:21:06.469Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="leetcode memo">
<meta name="twitter:description" content="739.Daily TemperaturesConcise: For each element, find the first element which is greater than it. Solution1: Monotonic stack  Time Complexity: O(n)Space Complexity: O(n) Solution2: Jump jump jump Time">





  
  
  <link rel="canonical" href="http://yoursite.com/2019/12/08/leetcode-memo/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>leetcode memo | Siil's Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Siil's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/08/leetcode-memo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Siil">
      <meta itemprop="description" content="博主是一个SB">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Siil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">leetcode memo

              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-08 20:11:19" itemprop="dateCreated datePublished" datetime="2019-12-08T20:11:19+08:00">2019-12-08</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-06 22:21:06" itemprop="dateModified" datetime="2020-01-06T22:21:06+08:00">2020-01-06</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="739-Daily-Temperatures"><a href="#739-Daily-Temperatures" class="headerlink" title="739.Daily Temperatures"></a>739.Daily Temperatures</h3><p>Concise: For each element, find the first element which is greater than it.</p>
<p>Solution1:</p>
<p>Monotonic stack </p>
<p>Time Complexity: O(n)<br>Space Complexity: O(n)</p>
<p>Solution2:</p>
<p>Jump jump jump</p>
<p>Time Complexity: O(n)<br>Space Complexity: O(n)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123;</span><br><span class="line">        vector&lt;pair&lt;int, int&gt; &gt; stack; // pair(value, position)</span><br><span class="line">        vector&lt;int&gt; result(T.size(), 0);</span><br><span class="line">        for(int i = T.size() - 1; i &gt; -1; i--) &#123;</span><br><span class="line">            for(result[i] = i + 1; result[i] &lt; T.size() &amp;&amp; T[i] &gt;= T[result[i]]; result[i] = result[result[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; T.size(); i++) &#123;</span><br><span class="line">            if(result[i] == T.size())</span><br><span class="line">                result[i] = 0;</span><br><span class="line">            else</span><br><span class="line">                result[i] = result[i] - i;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="621-Task-Scheduler"><a href="#621-Task-Scheduler" class="headerlink" title="621. Task Scheduler"></a>621. Task Scheduler</h3><p>Concise: Schedule tasks, same task could be ran after a cooling interval.</p>
<p>Solution:<br>Find the period of a group of task.<br>eg.<br>|Axxxx|Axxxx|Axxxx|Axxxxxx</p>
<p>Time Compelexity: O(n)<br>Space Compelexity: O(C) C is charcter set.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int leastInterval(vector&lt;char&gt;&amp; tasks, int n) &#123;</span><br><span class="line">        vector&lt;int&gt; cnt(26);</span><br><span class="line">        for(char &amp; c : tasks) &#123;</span><br><span class="line">            cnt[c - &apos;A&apos;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        int maxCnt = 0;</span><br><span class="line">        for(auto &amp; num : cnt) &#123;</span><br><span class="line">            maxCnt = max(maxCnt, num);</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = (maxCnt - 1) * (n + 1);</span><br><span class="line">        for(auto &amp; num : cnt) &#123;</span><br><span class="line">            if(num == maxCnt)</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, int(tasks.size()));</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="581-Shortest-Unsorted-Continuous-Subarray"><a href="#581-Shortest-Unsorted-Continuous-Subarray" class="headerlink" title="581. Shortest Unsorted Continuous Subarray"></a>581. Shortest Unsorted Continuous Subarray</h3><p>Concise: Find a subarray after it sorted will make entire array be ordered.</p>
<p>Solution1:</p>
<p>copy orignal array, sort it, and compare each position.</p>
<p>Time Complexity: O(nlogn)<br>Space Complexity: O(n)</p>
<p>Solution2:</p>
<p>Contract from two side, then find the max and min number in the middle, then enlarge two bound untile left bound less than min, and right bound greater than max.</p>
<p>Time Complexity: O(n)<br>Space Complexity: O(1)</p>
<p>One pass</p>
<p>Cautions: conor case<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int left = 0, right = nums.size() - 1;</span><br><span class="line">        while(left + 1 &lt; nums.size() &amp;&amp; nums[left + 1] &gt;= nums[left])</span><br><span class="line">            left++;</span><br><span class="line">        while(right &gt; left &amp;&amp; nums[right - 1] &lt;= nums[right])</span><br><span class="line">            right--;</span><br><span class="line">        int mx = nums[left], mn = nums[right];</span><br><span class="line">        for(int i = left; i &lt; right; i++) &#123;</span><br><span class="line">            mx = max(mx, nums[i]);</span><br><span class="line">            mn = min(mn, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        while(left &gt; -1 &amp;&amp; nums[left] &gt; mn) left--;</span><br><span class="line">        while(right &lt; nums.size() &amp;&amp; nums[right] &lt; mx) right++;</span><br><span class="line">        return max(0, right - left - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="448-Find-All-Numbers-Disappeared-in-an-Array"><a href="#448-Find-All-Numbers-Disappeared-in-an-Array" class="headerlink" title="448. Find All Numbers Disappeared in an Array"></a>448. Find All Numbers Disappeared in an Array</h3><p>Solution1:<br>use another visiter array.</p>
<p>Time Complexity: O(n)<br>Space Complexity: O(n)</p>
<p>Solution2:<br>use original array index and minus and positive number.</p>
<p>Time Complexity: O(n)<br>Space Complexity: O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        for(int c: nums)&#123;</span><br><span class="line">            if(nums[abs(c)-1]&lt;0)continue;</span><br><span class="line">            nums[abs(c)-1]*=-1;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        for(int i=0; i&lt;nums.size(); i++)</span><br><span class="line">            if(nums[i]&gt;0)res.push_back(i+1);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="394-Decode-String"><a href="#394-Decode-String" class="headerlink" title="394. Decode String"></a>394. Decode String</h3><p>Leared: isdigit(char)<br>Concise:<br>eg.<br>s = “3[a]2[bc]”, return “aaabcbc”.<br>s = “3[a2[c]]”, return “accaccacc”.<br>s = “2[abc]3[cd]ef”, return “abcabccdcdcdef”.</p>
<p>Solution1:<br>iterate</p>
<p>Time Complexity: O(n^2)<br>Space Complexity: O(n)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int get(string &amp; s, int pos) &#123;</span><br><span class="line">        while(pos - 1 &gt; -1 &amp;&amp; s[pos - 1] &lt;= &apos;9&apos; &amp;&amp; s[pos - 1] &gt;= &apos;0&apos;)</span><br><span class="line">            pos--;</span><br><span class="line">        int ret = 0;</span><br><span class="line">        while(pos &lt; s.size() &amp;&amp; s[pos] &lt;= &apos;9&apos; &amp;&amp; s[pos] &gt;= &apos;0&apos;) &#123;</span><br><span class="line">            ret = ret * 10 + s[pos] - &apos;0&apos;;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    string decodeString(string s) &#123;</span><br><span class="line">        s = &quot;1[&quot; + s + &quot;]&quot;;</span><br><span class="line">        vector&lt;int&gt; s1;</span><br><span class="line">        vector&lt;string&gt; s2;</span><br><span class="line">        for(int i = 0; i &lt; s.size(); i++) &#123;</span><br><span class="line">            if(s[i] == &apos;[&apos;) &#123;</span><br><span class="line">                int k = get(s, i - 1);</span><br><span class="line">                s1.push_back(k);</span><br><span class="line">                s2.push_back(&quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(s[i] == &apos;]&apos;) &#123;</span><br><span class="line">                string catStr = s2.back();</span><br><span class="line">                string str;</span><br><span class="line">                int k = s1.back();</span><br><span class="line">                s1.pop_back();</span><br><span class="line">                s2.pop_back();</span><br><span class="line">                if(s2.size()) &#123;</span><br><span class="line">                    str = s2.back();</span><br><span class="line">                    s2.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                for(int j = 0; j &lt; k; j++)</span><br><span class="line">                    str += catStr;</span><br><span class="line">                s2.push_back(str);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(s[i] &lt; &apos;0&apos; || s[i] &gt;&apos;9&apos;) &#123;</span><br><span class="line">                s2.back() += s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s2.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Solution2:<br>recursive.</p>
<p>Time Complexity: O(n^2)<br>Space Complexity: O(n)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string decodeString(string &amp; s, int &amp; pos) &#123;</span><br><span class="line">        string ret = &quot;&quot;;</span><br><span class="line">        while(pos &lt; s.size() &amp;&amp; s[pos] != &apos;]&apos;) &#123;</span><br><span class="line">            if(!isdigit(s[pos]))</span><br><span class="line">                ret += s[pos++];</span><br><span class="line">            else &#123;</span><br><span class="line">                int k = 0;</span><br><span class="line">                while(pos &lt; s.size() &amp;&amp; isdigit(s[pos])) &#123;</span><br><span class="line">                    k = k * 10 + s[pos] - &apos;0&apos;;</span><br><span class="line">                    pos++;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                pos++;</span><br><span class="line">                string str = decodeString(s, pos);</span><br><span class="line">                pos++;</span><br><span class="line">                for(int i = 0; i &lt; k; i++)</span><br><span class="line">                    ret += str;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    string decodeString(string s) &#123;</span><br><span class="line">        int pos = 0;</span><br><span class="line">        return decodeString(s, pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="347-Top-K-Frequent-Elements"><a href="#347-Top-K-Frequent-Elements" class="headerlink" title="347. Top K Frequent Elements"></a>347. Top K Frequent Elements</h3><p>Learned: nth_element(first, first + k, end);<br>Concise:<br>Solution1:<br>nth_element(first, first + k, end);<br>Time Complexity: O(n)<br>Space Complexity: O(n)</p>
<p>Solution2:<br>bucket sort<br>Time Complexity: O(n)<br>Space Complexity: O(n)</p>
<h3 id="312-Burst-Balloons"><a href="#312-Burst-Balloons" class="headerlink" title="312. Burst Balloons"></a>312. Burst Balloons</h3><p>Learned: vector.insert(it, val) insert val before it;</p>
<p>Solution:<br>f[left][right] means the max profit can be got after eliminated all elements in (left, right)<br>Transition: f[left][right] = f[left][mid] + f[mid][right] + nums[mid] <em> nums[left] </em> nums[right];</p>
<p>Time Complexity: O(n^3)<br>Space Complexity: O(n^2)</p>
<h3 id="301-Remove-Invalid-Parentheses"><a href="#301-Remove-Invalid-Parentheses" class="headerlink" title="301. Remove Invalid Parentheses"></a>301. Remove Invalid Parentheses</h3><p>Learned: vector<string>(set<string>.begin(), set<string>.end());<br>Concise: dfs<br>Solution:<br>Time Complexity: O(stringOP*2^(leftCount + rightCount));<br>Space Complexity: O(all case of valid string)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void removeParentheses(int pair, int idx, int leftCount, int rightCount, string curr, string &amp; s, unordered_set&lt;string&gt; &amp; result) &#123;</span><br><span class="line">        if(idx == s.size()) &#123;</span><br><span class="line">            if(leftCount == 0 &amp;&amp; rightCount == 0 &amp;&amp; pair == 0)</span><br><span class="line">                result.insert(curr);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s[idx] == &apos;(&apos;) &#123;</span><br><span class="line">            if(leftCount) &#123;</span><br><span class="line">                removeParentheses(pair, idx + 1, leftCount - 1, rightCount, curr, s, result);</span><br><span class="line">            &#125;</span><br><span class="line">            removeParentheses(pair + 1, idx + 1, leftCount, rightCount, curr + &apos;(&apos;, s, result);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(s[idx] == &apos;)&apos;) &#123;</span><br><span class="line">            if(pair)</span><br><span class="line">                removeParentheses(pair - 1, idx + 1, leftCount, rightCount, curr + &apos;)&apos;, s, result);</span><br><span class="line">            if(rightCount)</span><br><span class="line">                removeParentheses(pair, idx + 1, leftCount, rightCount - 1, curr, s, result);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            removeParentheses(pair, idx + 1, leftCount, rightCount, curr + s[idx], s, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; removeInvalidParentheses(string s) &#123;</span><br><span class="line">        unordered_set&lt;string&gt; result;</span><br><span class="line">        int leftCount = 0, rightCount = 0;</span><br><span class="line">        for(char &amp; c : s) &#123;</span><br><span class="line">            if(c == &apos;(&apos;) &#123;</span><br><span class="line">                leftCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(c == &apos;)&apos;) &#123;</span><br><span class="line">                if(leftCount &gt; 0) leftCount--;</span><br><span class="line">                else rightCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        removeParentheses(0, 0, leftCount, rightCount, &quot;&quot;, s, result);</span><br><span class="line">        return vector&lt;string&gt;(result.begin(), result.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></string></string></string></p>
<h3 id="287-Find-the-Duplicate-Number"><a href="#287-Find-the-Duplicate-Number" class="headerlink" title="287. Find the Duplicate Number"></a>287. Find the Duplicate Number</h3><p>Solution1:<br>Learned: fast low runner<br>proof:</p>
<ol>
<li>assume the distance from start point to the start point of loop is x1</li>
<li>assume the distance from start point of loop to fast and low runner meet point is x2</li>
<li>assume the distacne from meet point to the start point of loop is x3<br>fast = x1 + x2 + x3 + x2<br>low = x1 + x2<br>2 * low = fast<br>=&gt; x1 = x3<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int low = nums[0];</span><br><span class="line">        int fast = nums[nums[0]];</span><br><span class="line">        while(low != fast) &#123;</span><br><span class="line">            low = nums[low];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line">        fast = 0;</span><br><span class="line">        while(fast != low) &#123;</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">            low = nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        return low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Solution2:<br>binary search</p>
<h3 id="240-Search-a-2D-Matrix-II"><a href="#240-Search-a-2D-Matrix-II" class="headerlink" title="240. Search a 2D Matrix II"></a>240. Search a 2D Matrix II</h3><p>Solution:<br>Binary search O(min(nlogm, mlogn))<br>walk from up right to down left<br>Time Complixity: O(n + m)<br>because each time we can eliminate a row or a column</p>
<h3 id="239-Sliding-Window-Maximum"><a href="#239-Sliding-Window-Maximum" class="headerlink" title="239. Sliding Window Maximum"></a>239. Sliding Window Maximum</h3><p>SOlution:<br>deque<br>assume now append number is a[i], and there is a number a[j] in the window. a[i] &gt;= a[j] &amp;&amp; i &gt; j<br>we can observe a[j] can’t be a answer anymore, because at each move after appended a[i], there is always a a[i] in the window.<br>Time Complixity: O(n)<br>Space Complixity: O(n)</p>
<h3 id="221-Maximal-Square"><a href="#221-Maximal-Square" class="headerlink" title="221. Maximal Square"></a>221. Maximal Square</h3><p>grid only contain 0,1, find the largest square only contain 1</p>
<p>Solution1:<br>Binary search<br>Time Complexity: O(n<em>m </em> log(max(n, m)))<br>Space Complexity: O(n * m)</p>
<p>Solution2:<br>Monotonic stack<br>maintain an increasing stack(height, width)</p>
<p>if pop the back element in the stack(assume it is A), then the width of A will add to the width of next element.</p>
<p>Time Complexity: O(n <em> m)<br>Space Complexity: O(n </em> m)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        if(matrix.size() == 0 || matrix[0].size() == 0)</span><br><span class="line">            return 0;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; prefixSum(matrix.size() + 1, vector&lt;int&gt;(matrix[0].size() + 1, 0));</span><br><span class="line">        for(int i = 0; i &lt; matrix.size(); i++)</span><br><span class="line">            for(int j = 0; j &lt; matrix[i].size(); j++) &#123;</span><br><span class="line">                if(matrix[i][j] == &apos;1&apos;)</span><br><span class="line">                    prefixSum[i + 1][j] = prefixSum[i][j] + 1;</span><br><span class="line">                else</span><br><span class="line">                    prefixSum[i + 1][j] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for(int i = matrix.size() - 1; i &gt; -1; i--) &#123;</span><br><span class="line">            vector&lt;pair&lt;int, int&gt; &gt; stack; // pair&lt;height, width&gt;</span><br><span class="line">            for(int j = 0; j &lt; matrix[i].size() + 1; j++) &#123;</span><br><span class="line">                int height = prefixSum[i + 1][j], width = 0;</span><br><span class="line">                while(stack.size() &amp;&amp; stack.back().first &gt;= height) &#123;</span><br><span class="line">                    width += stack.back().second;</span><br><span class="line">                    int length = min(stack.back().first, width);</span><br><span class="line">                    ans = max(ans, length * length);</span><br><span class="line">                    stack.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push_back(&#123;height, width + 1&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Solution3:<br>DP<br>f[i][j] means the max length of square which right down conor is (i, j)<br>f[i][j] = min(f[i - 1][j - 1], f[i][j - 1], f[i - 1][j]) + 1 (only if grid[i][j] == 1);<br>f[i][j] = 0 (only if grid[i][j] == 0);</p>
<p>Time Complexity: O(n * m)<br>Space Complexity: O(m)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        if(matrix.size() == 0 || matrix[0].size() == 0)</span><br><span class="line">            return 0;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; f(2, vector&lt;int&gt;(matrix[0].size() + 1, 0));</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for(int i = 0; i &lt; matrix.size(); i++) &#123;</span><br><span class="line">            for(int j = 0; j &lt; matrix[i].size() + 1; j++) &#123; </span><br><span class="line">                f[0][j] = f[1][j];</span><br><span class="line">                f[1][j] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 0; j &lt; matrix[i].size(); j++) if(matrix[i][j] == &apos;1&apos;)&#123;</span><br><span class="line">                f[1][j + 1] = min(min(f[0][j], f[1][j]), f[0][j + 1]) + 1;</span><br><span class="line">                ans = max(ans, f[1][j + 1] * f[1][j + 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a>206. Reverse Linked List</h3><p>a template for reverse linked list<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        ListNode * curr, * nxt;</span><br><span class="line">        curr = head;</span><br><span class="line">        head = NULL;</span><br><span class="line">        while(curr != NULL) &#123;</span><br><span class="line">            nxt = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = head;</span><br><span class="line">            head = curr;</span><br><span class="line">            curr = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="406-Queue-Reconstruction-by-Height"><a href="#406-Queue-Reconstruction-by-Height" class="headerlink" title="406. Queue Reconstruction by Height"></a>406. Queue Reconstruction by Height</h3><p>Concise: give inverse pair to reconstruct original array</p>
<p>Solution1:<br>first sort the array by increasing first element, no-decreasing second element.<br>iterater array, now the array is ordered, so the element didn’t iteratered is greater or equal than current element.<br>use BIT to maintain the information of “how many position doesn’t used”<br>Time Complexity: O(nlogn)<br>Space Complexity: O(n)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; BIT;</span><br><span class="line">    void upd(int idx, int val) &#123;</span><br><span class="line">        for(int i = idx; i &lt; BIT.size(); i += i &amp; -i) &#123;</span><br><span class="line">            BIT[i] += val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int qry(int val) &#123;</span><br><span class="line">        int pos = 0;</span><br><span class="line">        for(int bin = 11, sum = 0; bin &gt; -1; bin--) &#123;</span><br><span class="line">            if(pos + (1 &lt;&lt; bin) &lt; BIT.size() &amp;&amp; sum + BIT[pos + (1 &lt;&lt; bin)] &lt;= val) &#123;</span><br><span class="line">                pos = pos + (1 &lt;&lt; bin);</span><br><span class="line">                sum += BIT[pos];</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        return pos;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; result(people.size());</span><br><span class="line">        BIT = vector&lt;int&gt;(people.size() + 1);</span><br><span class="line">        for(int i = 1; i &lt;= people.size(); i++)</span><br><span class="line">            upd(i, 1);</span><br><span class="line">        sort(people.begin(), people.end(), [](const vector&lt;int&gt; &amp; a, const vector&lt;int&gt; &amp; b)&#123;</span><br><span class="line">           if(a[0] == b[0])</span><br><span class="line">               return a[1] &gt; b[1];</span><br><span class="line">            return a[0] &lt; b[0];</span><br><span class="line">        &#125;);</span><br><span class="line">        for(auto &amp; person : people) &#123;</span><br><span class="line">            int pos = qry(person[1]);</span><br><span class="line">            upd(pos + 1, -1);</span><br><span class="line">            result[pos] = person;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Solution2:<br>use Segment Tree with interval modification.<br>Time Complexity: O(nlogn)<br>Space COmplexity: O(nlogn)</p>
<h3 id="148-Sort-List"><a href="#148-Sort-List" class="headerlink" title="148. Sort List"></a>148. Sort List</h3><p>Solution1:<br>recursive<br>Time Complexity: O(nlogn)<br>Space Complexity: O(logn)</p>
<p>Solution2:<br>sort in place<br>helper function Merge and MoveKSteps<br>Time Complexity: O(nlogn)<br>Space Complexity: O(1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode * MoveKSteps(int step, ListNode * head) &#123;</span><br><span class="line">        ListNode * ret = head;</span><br><span class="line">        for(int i = 0; i &lt; step &amp;&amp; ret != NULL; i++) &#123;</span><br><span class="line">            ret = ret-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode * Merge(ListNode * lst1, ListNode * lst2) &#123;</span><br><span class="line">        if(lst1 == NULL)</span><br><span class="line">            return lst2;</span><br><span class="line">        if(lst2 == NULL)</span><br><span class="line">            return lst1;</span><br><span class="line">        ListNode * ret, * p;</span><br><span class="line">        if(lst1-&gt;val &lt; lst2-&gt;val) &#123;</span><br><span class="line">            ret = lst1;</span><br><span class="line">            lst1 = lst1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            ret = lst2;</span><br><span class="line">            lst2 = lst2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ret-&gt;next = NULL;</span><br><span class="line">        p = ret;</span><br><span class="line">        while(lst1 != NULL &amp;&amp; lst2 != NULL) &#123;</span><br><span class="line">            if(lst1-&gt;val &lt; lst2-&gt;val) &#123;</span><br><span class="line">                p-&gt;next = lst1;</span><br><span class="line">                lst1 = lst1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                p-&gt;next = lst2;</span><br><span class="line">                lst2 = lst2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            p-&gt;next = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        if(lst1 != NULL)</span><br><span class="line">            p-&gt;next = lst1;</span><br><span class="line">        if(lst2 != NULL)</span><br><span class="line">            p-&gt;next = lst2;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* sortList(ListNode* head) &#123;</span><br><span class="line">        ListNode * dummy = new ListNode(0), * begin, * mid, * end;</span><br><span class="line">        int length = 0;</span><br><span class="line">        begin = head;</span><br><span class="line">        for(length = 0; begin != NULL; begin = begin-&gt;next) &#123;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        for(int step = 1; step &lt; length; step &lt;&lt;= 1) &#123;</span><br><span class="line">            for(begin = dummy; begin != NULL; ) &#123;</span><br><span class="line">                mid = MoveKSteps(step, begin);</span><br><span class="line">                end = MoveKSteps(step, mid);</span><br><span class="line">                ListNode * lst1 = begin ? begin-&gt;next : NULL, * lst2 = mid ? mid-&gt;next : NULL, * nxt = end ? end-&gt;next : NULL;</span><br><span class="line">                if(end != NULL)</span><br><span class="line">                    end-&gt;next = NULL;</span><br><span class="line">                if(mid != NULL)</span><br><span class="line">                    mid-&gt;next = NULL;</span><br><span class="line">                begin-&gt;next = Merge(lst1, lst2);</span><br><span class="line">                begin = MoveKSteps(step &lt;&lt; 1, begin);</span><br><span class="line">                if(begin != NULL)</span><br><span class="line">                    begin-&gt;next = nxt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = dummy-&gt;next;</span><br><span class="line">        delete dummy;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="146-LRU-Cache"><a href="#146-LRU-Cache" class="headerlink" title="146. LRU Cache"></a>146. LRU Cache</h3><p>Solution1:<br>List<pair<key, value> &gt;;<br>unordered_map<key, list<pair<key, value>&gt; :: iterator&gt;;<br>Time Complexity: O(1)<br>Space Complexity: O(1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class LRUCache &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;int, list&lt;pair&lt;int, int&gt; &gt; :: iterator &gt; f;</span><br><span class="line">    list&lt;pair&lt;int, int&gt; &gt; cache;</span><br><span class="line">    int _capacity;</span><br><span class="line">    LRUCache(int capacity) &#123;</span><br><span class="line">        _capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    void PutToHead(int key) &#123;</span><br><span class="line">        int val = f[key]-&gt;second;</span><br><span class="line">        cache.erase(f[key]);</span><br><span class="line">        cache.push_front(&#123;key, val&#125;);</span><br><span class="line">        f[key] = cache.begin();</span><br><span class="line">    &#125;</span><br><span class="line">    int get(int key) &#123;</span><br><span class="line">        if(f.find(key) == f.end())</span><br><span class="line">            return -1;</span><br><span class="line">        PutToHead(key);</span><br><span class="line">        return cache.begin()-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void put(int key, int value) &#123;</span><br><span class="line">        if(f.find(key) != f.end()) &#123;</span><br><span class="line">            f[key]-&gt;second = value;</span><br><span class="line">            PutToHead(key);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        if(_capacity == 0) &#123;</span><br><span class="line">            f.erase(f.find(cache.rbegin()-&gt;first));</span><br><span class="line">            cache.pop_back();</span><br><span class="line">            _capacity++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        cache.push_front(&#123;key, value&#125;);</span><br><span class="line">        f[key] = cache.begin();</span><br><span class="line">        _capacity--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="line"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="line"> * int param_1 = obj-&gt;get(key);</span><br><span class="line"> * obj-&gt;put(key,value);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></key,></pair<key,></p>
<h3 id="128-Longest-Consecutive-Sequence"><a href="#128-Longest-Consecutive-Sequence" class="headerlink" title="128. Longest Consecutive Sequence"></a>128. Longest Consecutive Sequence</h3><p>Concise: Give an unordered array of interger, find the length of longest consecutive sequence.</p>
<p>Solution1:<br>dicrete originarray, then use disjoint set<br>Time Complexity: O(n)<br>Space Complexity: O(n)</p>
<p>Solution2:<br>we can obsereve that it only 3 cases.<br>case1: current num is at the midlle of two existed num<br>case2 &amp; case3: only one side is existed.<br>above 3 cases can be solved by a unordered map<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; cover;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for(int &amp;num : nums) &#123;</span><br><span class="line">            if(cover.count(num) != 0) </span><br><span class="line">                continue;</span><br><span class="line">            int leftLen = cover.count(num - 1) ? cover[num - 1] : 0;</span><br><span class="line">            int rightLen = cover.count(num + 1) ? cover[num + 1] : 0;</span><br><span class="line">            int len = leftLen + rightLen + 1;</span><br><span class="line">            cover[num] = len;</span><br><span class="line">            cover[num - leftLen] = len;</span><br><span class="line">            cover[num + rightLen] = len;</span><br><span class="line">            ans = max(ans, len);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="99-Recover-Binary-Search-Tree"><a href="#99-Recover-Binary-Search-Tree" class="headerlink" title="99. Recover Binary Search Tree"></a>99. Recover Binary Search Tree</h3><p>Concise: Given a BST which is swap two nodes in the tree, in case the tree is not in order in inorder traversal</p>
<p>Solution1:<br>do an inorder traversal find the two nodes which is unordered.<br>Time Complexity: O(n)<br>Space Complexity: O(n)</p>
<p>Solution2:<br>Morris Traversal<br>3 cases.</p>
<ol>
<li>current node doesn’t have left child</li>
<li>current node have left child and the most right child of the left child is NULL</li>
<li>current node have left child and the most right child of the left child is current node</li>
</ol>
<p>case 2: should link the most right child to current node<br>case 3: should unlink the most right child with current node</p>
<p>in the case 1 and case 3 current node is the first node in current inorder traversal<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void FindMistakePos(TreeNode * root, TreeNode * parent, TreeNode * &amp; lastNode, int cnt) &#123;</span><br><span class="line">        if(root == NULL)</span><br><span class="line">            return ;</span><br><span class="line">        FindMistakePos(root-&gt;left, root, lastNode);</span><br><span class="line">        if(lastNode == NULL || root-&gt;val &lt; lastNode-&gt;val) &#123;</span><br><span class="line">            lastNode = parent;</span><br><span class="line">            if(cnt == 0) &#123;</span><br><span class="line">                firstNode = parent;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                secondNode = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        lastNode = root;</span><br><span class="line">        FindMistakePos(root-&gt;right, root, lastNode);</span><br><span class="line">    &#125;</span><br><span class="line">    void recoverTree(TreeNode* root) &#123;</span><br><span class="line">        TreeNode * firstPos, * secondPos;</span><br><span class="line">        firstPos = secondPos = NULL;</span><br><span class="line">        int currVal = -1e9;</span><br><span class="line">        TreeNode * lastNode = NULL;</span><br><span class="line">        FindMistakePos(root, NULL, lastNode, 0);</span><br><span class="line">        if(secondNode == NULL || firstNode-&gt;val &lt; secondNode-&gt;val) </span><br><span class="line">            swap(firstNode, secondNode);</span><br><span class="line">        if(firstNode == NULL) &#123;</span><br><span class="line">            swap(root-&gt;left, secondNode-&gt;right-&gt;left);</span><br><span class="line">            swap(root-&gt;right, secondNode-&gt;right-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            swap(firstNode-&gt;left, secondNode-&gt;right-&gt;left);</span><br><span class="line">            swap(firstNode-&gt;right, secondNode-&gt;right-&gt;right);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="264-Ugly-Number-II"><a href="#264-Ugly-Number-II" class="headerlink" title="264. Ugly Number II"></a>264. Ugly Number II</h3><p>Concise: find the n-th number which only contain {2, 3, 5} as factors.</p>
<p>Solution1:<br>priority queue to simulate<br>Remember numbers might duplicated<br>Time Complexity: O(nlogn)<br>Space Complexity: O(n)</p>
<p>Solution2:<br>use 3 pointer<br>each time generate nxt number<br>eg:<br>kth[t2] <em> 2<br>kth[t3] </em> 3<br>kth[t5] * 5<br>choose the minimal number, then move all pointer which times its prime is equal to the nxt number.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int nthUglyNumber(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; kth(n);</span><br><span class="line">        kth[0] = 1;</span><br><span class="line">        int t2, t3, t5;</span><br><span class="line">        t2 = t3 = t5 = 0;</span><br><span class="line">        for(int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">            int nxt = min(kth[t2] * 2, min(kth[t3] * 3, kth[t5] * 5));</span><br><span class="line">            if(nxt == kth[t2] * 2) t2++;</span><br><span class="line">            if(nxt == kth[t3] * 3) t3++;</span><br><span class="line">            if(nxt == kth[t5] * 5) t5++;</span><br><span class="line">            kth[i + 1] = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        return kth[n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="417-Pacific-Atlantic-Water-Flow"><a href="#417-Pacific-Atlantic-Water-Flow" class="headerlink" title="417. Pacific Atlantic Water Flow"></a>417. Pacific Atlantic Water Flow</h3><p>Solution1:<br>DFS<br>Time Complexity: O(n)<br>Space Complexity: O(n)<br>Cautions: avoid to visit a cell twice.</p>
<h3 id="407-Trapping-Rain-Water-II"><a href="#407-Trapping-Rain-Water-II" class="headerlink" title="407. Trapping Rain Water II"></a>407. Trapping Rain Water II</h3><p>Solution:</p>
<p>Time Complexity: O(r <em> c </em> log(r * c))<br>Space Complexity: O(n)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trapRainWater(vector&lt;vector&lt;int&gt;&gt;&amp; heightMap) &#123;</span><br><span class="line">        if(heightMap.size() == 0)</span><br><span class="line">            return 0;</span><br><span class="line">        int n = heightMap.size(), m = heightMap[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; dist(n, vector&lt;int&gt;(m, -1));</span><br><span class="line">        priority_queue&lt;pair&lt;int, int&gt; &gt; q;</span><br><span class="line">        for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            q.push(&#123;-heightMap[i][0], i * m&#125;);</span><br><span class="line">            q.push(&#123;-heightMap[i][m - 1], i * m + m - 1&#125;);</span><br><span class="line">            dist[i][0] = heightMap[i][0];</span><br><span class="line">            dist[i][m - 1] = heightMap[i][m - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; m - 1; i++) &#123;</span><br><span class="line">            q.push(&#123;-heightMap[0][i], i&#125;);</span><br><span class="line">            q.push(&#123;-heightMap[n - 1][i], (n - 1) * m + i&#125;);</span><br><span class="line">            dist[0][i] = heightMap[0][i];</span><br><span class="line">            dist[n - 1][i] = heightMap[n - 1][i];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; dy = &#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">        while(q.size()) &#123;</span><br><span class="line">            int d = -q.top().first, x = q.top().second / m, y = q.top().second % m;</span><br><span class="line">            q.pop();</span><br><span class="line">            for(vector&lt;int&gt; &amp; dx : dy) &#123;</span><br><span class="line">                int nx = x + dx[0], ny = y + dx[1];</span><br><span class="line">                if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || dist[nx][ny] != -1) continue;</span><br><span class="line">                dist[nx][ny] = max(d, heightMap[nx][ny]);</span><br><span class="line">                q.push(&#123;-dist[nx][ny], nx * m + ny&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)</span><br><span class="line">            for(int j = 0; j &lt; m; j++)</span><br><span class="line">                ans += dist[i][j] - heightMap[i][j];</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="72-Edit-Distance"><a href="#72-Edit-Distance" class="headerlink" title="72. Edit Distance"></a>72. Edit Distance</h3><p>3 operators:</p>
<ol>
<li>isnert a letter.</li>
<li>delete a letter.</li>
<li>replace a letter.<br>find the minimum edit distance.</li>
</ol>
<p>Solution:<br>DP<br>if(word1[i] == word2[j])<br>f[i][j] = f[i - 1][j - 1]<br>otherwise<br>f[i][j] = f[i - 1][j] + 1 (delete operator)<br>f[i][j] = f[i][j - 1] + 1 (insert operator)<br>f[i][j] = f[i - 1][j - 1] + 1 (replace operator)</p>
<p>Time Complexity: O(n <em> m)<br>Space Complexity: naive O(n </em> m)<br>                  rolling array optimal O(n)<br>Cautions: initialize<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDistance(string word1, string word2) &#123;</span><br><span class="line">        //vector&lt;vector&lt;int&gt; &gt; f(word1.size() + 1, vector&lt;int&gt;(word2.size() + 1));</span><br><span class="line">        vector&lt;int&gt; f(word2.size() + 1);</span><br><span class="line">        vector&lt;int&gt; g(word2.size() + 1);</span><br><span class="line">        for(int i = 0; i &lt; word2.size(); i++)</span><br><span class="line">            g[i + 1] = i + 1;</span><br><span class="line">        for(int i = 0; i &lt; word1.size(); i++) &#123;</span><br><span class="line">            f[0] = i + 1;</span><br><span class="line">            for(int j = 0; j &lt; word2.size(); j++) &#123;</span><br><span class="line">                f[j + 1] = g[j] + (word1[i] != word2[j]);</span><br><span class="line">                f[j + 1] = min(f[j + 1], f[j] + 1);</span><br><span class="line">                f[j + 1] = min(f[j + 1], g[j + 1] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 0; j &lt; g.size(); j++) &#123;</span><br><span class="line">                g[j] = f[j];</span><br><span class="line">                f[j] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return g[word2.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="56-Merge-Intervals"><a href="#56-Merge-Intervals" class="headerlink" title="56. Merge Intervals"></a>56. Merge Intervals</h3><p>Concise: merge overlapping intervals.</p>
<p>Solution1:<br>Time Complexity: O(nlogn)<br>Space Complexity: O(n)</p>
<p>Solution2:<br>use a stack<br>Time Complexity: O(nlogn)<br>Space Complexity: O(n)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        if(intervals.size() == 0)</span><br><span class="line">            return vector&lt;vector&lt;int&gt; &gt;();</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; ans;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), [](vector&lt;int&gt; &amp; a, vector&lt;int&gt; &amp; b)&#123;return a[0] &lt; b[0];&#125;);</span><br><span class="line">        ans.push_back(intervals[0]);</span><br><span class="line">        for(int i = 1; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">            if(intervals[i][0] &gt; ans.back()[1]) &#123;</span><br><span class="line">                ans.push_back(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                ans.back()[1] = max(ans.back()[1], intervals[i][1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="32-Longest-Valid-Parentheses"><a href="#32-Longest-Valid-Parentheses" class="headerlink" title="32. Longest Valid Parentheses"></a>32. Longest Valid Parentheses</h3><p>Concise: find the longest valid parentheses substring</p>
<p>Solution1:<br>stack<br>Time Complexity: O(n)<br>Space Complexity: O(n)</p>
<p>Solution2:<br>dp<br>f[i] means {the longest valid parentheses substring ended in i of s[0..i]}<br>f[i] = f[i - 2] + 2; if(s[i] == ‘)’ &amp;&amp; s[i - 1] == ‘(‘)<br>f[i] = f[i - 1] + f[i - f[i - 1] - 2] + 2; if(s[i] == ‘)’ &amp;&amp; s[i - 1] == ‘)’ &amp;&amp; s[i - f[i - 1] - 1] == ‘(‘)</p>
<p>Time Complexity: O(n)<br>Space Complexity: O(n)</p>
<p>Solution3:<br>greedy<br>the longest valid parentheses only has two cases</p>
<ol>
<li>the minimal number of one end is ‘(‘</li>
<li>the minimal number of one end is ‘)’<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestValidParentheses(string s) &#123;</span><br><span class="line">        int lcnt, rcnt;</span><br><span class="line">        lcnt = rcnt = 0;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if(s[i] == &apos;(&apos;)</span><br><span class="line">                lcnt++;</span><br><span class="line">            else &#123;</span><br><span class="line">                rcnt++;</span><br><span class="line">                if(rcnt == lcnt)</span><br><span class="line">                    ans = max(ans, lcnt + rcnt);</span><br><span class="line">                if(rcnt &gt; lcnt)</span><br><span class="line">                    lcnt = rcnt = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lcnt = rcnt = 0;</span><br><span class="line">        for(int i = n - 1; i &gt; -1; i--) &#123;</span><br><span class="line">            if(s[i] == &apos;(&apos;) &#123;</span><br><span class="line">                lcnt++;</span><br><span class="line">                if(lcnt == rcnt)</span><br><span class="line">                    ans = max(ans, lcnt + rcnt);</span><br><span class="line">                if(lcnt &gt; rcnt)</span><br><span class="line">                    lcnt = rcnt = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                rcnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Time Complexity: O(n)<br>Space Complexity: O(1)</p>
<h3 id="10-Regular-Expression-Matching"><a href="#10-Regular-Expression-Matching" class="headerlink" title="10. Regular Expression Matching"></a>10. Regular Expression Matching</h3><p>Solution1:<br>dp<br>f[i][j] mmeans {p[0..i] matchs s[0..j]}<br>3 cases to transfer</p>
<ol>
<li>f[i][j] = f[i - 2][j]; if(use 0 time ‘*’)</li>
<li>f[i][j] = f[i][j - 1]; if(use at least 1 time ‘*’)</li>
<li>f[i][j] = f[i - 1][j - 1] if(p[i] != ‘*’ &amp;&amp; p[i] == s[j])<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool helper(char &amp; a, char &amp; b) &#123;</span><br><span class="line">        if(a == &apos;.&apos;)</span><br><span class="line">            return true;</span><br><span class="line">        return a == b;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isMatch(string s, string p) &#123;</span><br><span class="line">        int n = p.size(), m = s.size();</span><br><span class="line">        vector&lt;vector&lt;bool&gt; &gt; f(p.size() + 1, vector&lt;bool&gt;(s.size() + 1));</span><br><span class="line">        f[0][0] = 1;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)</span><br><span class="line">            if(p[i] == &apos;*&apos;)</span><br><span class="line">                f[i + 1][0] = f[i - 1][0];</span><br><span class="line">        for(int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">                if(p[i] == &apos;*&apos;) &#123;</span><br><span class="line">                    if(helper(p[i - 1], s[j])) &#123;</span><br><span class="line">                        f[i + 1][j + 1] = f[i - 1][j + 1] || f[i + 1][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        f[i + 1][j + 1] = f[i - 1][j + 1];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(helper(p[i], s[j]))&#123;</span><br><span class="line">                    f[i + 1][j + 1] = f[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="1296-Divide-Array-in-Sets-of-K-Consecutive-Numbers"><a href="#1296-Divide-Array-in-Sets-of-K-Consecutive-Numbers" class="headerlink" title="1296. Divide Array in Sets of K Consecutive Numbers"></a>1296. Divide Array in Sets of K Consecutive Numbers</h3><p>SOlution1:<br>map<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPossibleDivide(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        if(n % k != 0)</span><br><span class="line">            return false;</span><br><span class="line">        map&lt;int, int&gt; cnt;</span><br><span class="line">        for(int &amp; num : nums)</span><br><span class="line">            cnt[num]++;</span><br><span class="line">        for(auto &amp; it : cnt) &#123;</span><br><span class="line">            int t = it.second;</span><br><span class="line">            if(t == 0) continue;</span><br><span class="line">            for(int dx = 0; dx &lt; k; dx++) &#123;</span><br><span class="line">                int num = it.first + dx;</span><br><span class="line">                if(cnt.count(num) == 0 )</span><br><span class="line">                    return false;</span><br><span class="line">                cnt[num] -= t;</span><br><span class="line">                if(cnt[num] &lt; 0)</span><br><span class="line">                    return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Time Complexity: O(nlogn)<br>Space Complexity: O(n)</p>
<p>Solution2:<br>unordered_map<br>find the start position of the consecutive sequence<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPossibleDivide(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        if(n % k != 0)</span><br><span class="line">            return false;</span><br><span class="line">        unordered_map&lt;int, int&gt; cnt;</span><br><span class="line">        for(int &amp; num : nums)</span><br><span class="line">            cnt[num]++;</span><br><span class="line">        for(auto &amp; it : cnt) &#123;</span><br><span class="line">            if(it.second == 0) continue;</span><br><span class="line">            int t = it.first;</span><br><span class="line">            while(cnt.count(t - 1) &amp;&amp; cnt[t - 1] != 0)</span><br><span class="line">                t--;</span><br><span class="line">            for(int num = t; cnt.count(num + 1); num++) &#123;</span><br><span class="line">                if(cnt[num] == 0) continue;</span><br><span class="line">                int cur = cnt[num];</span><br><span class="line">                for(int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">                    if(cnt.count(i + num) == 0)</span><br><span class="line">                        return false;</span><br><span class="line">                    cnt[i + num] -= cur;</span><br><span class="line">                    if(cnt[i + num] &lt; 0)</span><br><span class="line">                        return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Time Complexity: O(n)<br>Space Complexity: O(n)</p>
<h3 id="659-Split-Array-into-Consecutive-Subsequences"><a href="#659-Split-Array-into-Consecutive-Subsequences" class="headerlink" title="659. Split Array into Consecutive Subsequences"></a>659. Split Array into Consecutive Subsequences</h3><p>solution:<br>greedy, each time add current number to the subsequences which has minimal length.<br>length &gt; 3, so we could use 3 counter to do this.</p>
<ol>
<li>counter1 is end with num and length is 1</li>
<li>counter2 is end with num and length is 2</li>
<li>counter3 is end with num and length greater or equal to 3<br>Time Complexity: O(n)<br>Space Complexity: O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPossible(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int ones = 0, twos = 0, others;</span><br><span class="line">        for(int l = 0, r = 0, las = INT_MIN; l &lt; nums.size(); l = r) &#123;</span><br><span class="line">            while(r &lt; nums.size() &amp;&amp; nums[r] == nums[l])</span><br><span class="line">                r++;</span><br><span class="line">            int cnt = r - l;</span><br><span class="line">            if(las != nums[l] - 1) &#123;</span><br><span class="line">                if(ones != 0 || twos != 0)</span><br><span class="line">                    return false;</span><br><span class="line">                ones = cnt;</span><br><span class="line">                others = two = 0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if(cnt &lt; ones + twos)</span><br><span class="line">                    return false;</span><br><span class="line">                cnt -= ones + twos;</span><br><span class="line">                others = min(others, cnt);</span><br><span class="line">                cnt -= others;</span><br><span class="line">                others += twos;</span><br><span class="line">                twos = ones;</span><br><span class="line">                ones = cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            las = nums[l];</span><br><span class="line">        &#125;</span><br><span class="line">        return ones == 0 &amp;&amp; twos == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="1287-Element-Appearing-More-Than-25-In-Sorted-Array"><a href="#1287-Element-Appearing-More-Than-25-In-Sorted-Array" class="headerlink" title="1287. Element Appearing More Than 25% In Sorted Array"></a>1287. Element Appearing More Than 25% In Sorted Array</h3><p>Learn: distance(begin, end)<br>because the element appearing more than 25%<br>so it must appear in one of {sz / 4, sz / 2, sz * 3 / 4} these 3 positions<br>chech this three position<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findSpecialInteger(vector&lt;int&gt;&amp; arr) &#123;</span><br><span class="line">        int n = arr.size();</span><br><span class="line">        vector&lt;int&gt; candidate = &#123;arr[n / 4], arr[n / 2], arr[n * 3 / 4]&#125;;</span><br><span class="line">        for(auto &amp; cand : candidate) &#123;</span><br><span class="line">            auto be = lower_bound(arr.begin(), arr.end(), cand);</span><br><span class="line">            auto ed = upper_bound(arr.begin(), arr.end(), cand);</span><br><span class="line">            if(4 * distance(be, ed) &gt; arr.size())</span><br><span class="line">                return cand;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="1138-Alphabet-Board-Path"><a href="#1138-Alphabet-Board-Path" class="headerlink" title="1138. Alphabet Board Path"></a>1138. Alphabet Board Path</h3><p>Concise:<br>give a board below<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abcde</span><br><span class="line">fghij</span><br><span class="line">klmno</span><br><span class="line">pqrst</span><br><span class="line">uvwxy</span><br><span class="line">z</span><br></pre></td></tr></table></figure></p>
<p>can move up, right, down, left if the cell exist<br>and append the character in current position to the ans<br>calculate the path to get target</p>
<p>Cautions:<br>‘z’ is a special case<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string alphabetBoardPath(string target) &#123;</span><br><span class="line">        unordered_map&lt;char, pair&lt;int, int&gt; &gt; board;</span><br><span class="line">        for(int i = 0; i &lt; 5; i++)</span><br><span class="line">            for(int j = 0; j &lt; 5; j++)</span><br><span class="line">                board[i * 5 + j + &apos;a&apos;] = &#123;i, j&#125;;</span><br><span class="line">        board[&apos;z&apos;] = &#123;5, 0&#125;;</span><br><span class="line">        string ans;</span><br><span class="line">        char cur = &apos;a&apos;;</span><br><span class="line">        for(char &amp; c : target) &#123;</span><br><span class="line">            int dx = board[cur].first - board[c].first;</span><br><span class="line">            int dy = board[cur].second - board[c].second;</span><br><span class="line">            if(c == &apos;z&apos;) &#123;</span><br><span class="line">                if(dy != 0) &#123;</span><br><span class="line">                    char dir = (dy &gt; 0) ? &apos;L&apos; : &apos;R&apos;;</span><br><span class="line">                    ans += string(abs(dy), dir);</span><br><span class="line">                &#125;</span><br><span class="line">                if(dx != 0) &#123;</span><br><span class="line">                    char dir = (dx &gt; 0) ? &apos;U&apos; : &apos;D&apos;;</span><br><span class="line">                    ans += string(abs(dx), dir);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if(dx != 0) &#123;</span><br><span class="line">                    char dir = (dx &gt; 0) ? &apos;U&apos; : &apos;D&apos;;</span><br><span class="line">                    ans += string(abs(dx), dir);</span><br><span class="line">                &#125;</span><br><span class="line">                if(dy != 0) &#123;</span><br><span class="line">                    char dir = (dy &gt; 0) ? &apos;L&apos; : &apos;R&apos;;</span><br><span class="line">                    ans += string(abs(dy), dir);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += &apos;!&apos;;</span><br><span class="line">            cur = c;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/01/Recent-States/" rel="next" title="Recent States">
                <i class="fa fa-chevron-left"></i> Recent States
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/28/Atcoder-Training/" rel="prev" title="Atcoder Training">
                Atcoder Training <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Siil</p>
              <div class="site-description motion-element" itemprop="description">博主是一个SB</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#739-Daily-Temperatures"><span class="nav-number">1.</span> <span class="nav-text">739.Daily Temperatures</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#621-Task-Scheduler"><span class="nav-number">2.</span> <span class="nav-text">621. Task Scheduler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#581-Shortest-Unsorted-Continuous-Subarray"><span class="nav-number">3.</span> <span class="nav-text">581. Shortest Unsorted Continuous Subarray</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#448-Find-All-Numbers-Disappeared-in-an-Array"><span class="nav-number">4.</span> <span class="nav-text">448. Find All Numbers Disappeared in an Array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#394-Decode-String"><span class="nav-number">5.</span> <span class="nav-text">394. Decode String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#347-Top-K-Frequent-Elements"><span class="nav-number">6.</span> <span class="nav-text">347. Top K Frequent Elements</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#312-Burst-Balloons"><span class="nav-number">7.</span> <span class="nav-text">312. Burst Balloons</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#301-Remove-Invalid-Parentheses"><span class="nav-number">8.</span> <span class="nav-text">301. Remove Invalid Parentheses</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#287-Find-the-Duplicate-Number"><span class="nav-number">9.</span> <span class="nav-text">287. Find the Duplicate Number</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#240-Search-a-2D-Matrix-II"><span class="nav-number">10.</span> <span class="nav-text">240. Search a 2D Matrix II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#239-Sliding-Window-Maximum"><span class="nav-number">11.</span> <span class="nav-text">239. Sliding Window Maximum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#221-Maximal-Square"><span class="nav-number">12.</span> <span class="nav-text">221. Maximal Square</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#206-Reverse-Linked-List"><span class="nav-number">13.</span> <span class="nav-text">206. Reverse Linked List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#406-Queue-Reconstruction-by-Height"><span class="nav-number">14.</span> <span class="nav-text">406. Queue Reconstruction by Height</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#148-Sort-List"><span class="nav-number">15.</span> <span class="nav-text">148. Sort List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#146-LRU-Cache"><span class="nav-number">16.</span> <span class="nav-text">146. LRU Cache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#128-Longest-Consecutive-Sequence"><span class="nav-number">17.</span> <span class="nav-text">128. Longest Consecutive Sequence</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#99-Recover-Binary-Search-Tree"><span class="nav-number">18.</span> <span class="nav-text">99. Recover Binary Search Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#264-Ugly-Number-II"><span class="nav-number">19.</span> <span class="nav-text">264. Ugly Number II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#417-Pacific-Atlantic-Water-Flow"><span class="nav-number">20.</span> <span class="nav-text">417. Pacific Atlantic Water Flow</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#407-Trapping-Rain-Water-II"><span class="nav-number">21.</span> <span class="nav-text">407. Trapping Rain Water II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#72-Edit-Distance"><span class="nav-number">22.</span> <span class="nav-text">72. Edit Distance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#56-Merge-Intervals"><span class="nav-number">23.</span> <span class="nav-text">56. Merge Intervals</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-Longest-Valid-Parentheses"><span class="nav-number">24.</span> <span class="nav-text">32. Longest Valid Parentheses</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-Regular-Expression-Matching"><span class="nav-number">25.</span> <span class="nav-text">10. Regular Expression Matching</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1296-Divide-Array-in-Sets-of-K-Consecutive-Numbers"><span class="nav-number">26.</span> <span class="nav-text">1296. Divide Array in Sets of K Consecutive Numbers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#659-Split-Array-into-Consecutive-Subsequences"><span class="nav-number">27.</span> <span class="nav-text">659. Split Array into Consecutive Subsequences</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1287-Element-Appearing-More-Than-25-In-Sorted-Array"><span class="nav-number">28.</span> <span class="nav-text">1287. Element Appearing More Than 25% In Sorted Array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1138-Alphabet-Board-Path"><span class="nav-number">29.</span> <span class="nav-text">1138. Alphabet Board Path</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Siil</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/affix.js?v=7.1.2"></script>

  <script src="/js/schemes/pisces.js?v=7.1.2"></script>



  
  <script src="/js/scrollspy.js?v=7.1.2"></script>
<script src="/js/post-details.js?v=7.1.2"></script>



  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  


  


  




  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
